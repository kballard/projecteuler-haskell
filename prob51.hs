-- By replacing the 1st digit of *3, it turns out that six of the nine possible
-- values: 13, 23, 43, 53, 73, and 83, are all prime.
--
-- By replacing the 3rd and 4th digits of 56**3 with the same digit, this
-- 5-digit number is the first example having seven primes among the ten
-- generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663,
-- 56773, and 56993. Consequently 56003, being the first member of this family,
-- is the smallest prime with this property.
--
-- Find the smallest prime which, by replacing part of the number (not
-- necessarily adjacent digits) with the same digit, is part of an eight prime
-- value family.
--

import Control.Monad
import Control.Monad.Instances
import Data.List (sort, group, find)
import Data.Maybe (fromJust)
import qualified Data.Numbers.Primes as P
import Euler.Numbers

primes :: (Integral a) => [a]
primes = dropWhile (<=56003) P.primes

-- Takes a list of digits and spits out a list of every digit
-- that occurs at least twice in the input list
repeatedDigits :: [Int] -> [Int]
repeatedDigits = map head . filter ((>1).length) . group . sort

-- replaces all instances of an element with another element
replace :: (Eq a) => a -> a -> [a] -> [a]
replace a b = map step
  where step c | a == c = b
               | otherwise = c

-- primeSequence takes a number and returns a nested list of
-- all primes generated by swapping repeated digits with 0..9
-- Each separate list is a different repeated digit being swapped
primeSequence :: (Integral n) => n -> [[n]]
primeSequence = map (filter P.isPrime) . (makeCandidates =<< repeatedDigits) . numToDigits
  where makeCandidates :: (Integral n) => [Int] -> [Int] -> [[n]]
        makeCandidates cs ds = do
          c <- cs
          let l :: (Integral n) => [n]
              l = do
              i <- [0..9]
              guard $ i /= 0 || head ds /= c
              return $ digitsToNum $ replace c i ds
          guard $ not (null l)
          return l

main :: IO ()
main = do
  print $ fromJust $ find ((==8).length) $ concat $ map primeSequence primes
